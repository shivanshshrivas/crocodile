{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-4b1b45a0ae404438a2ac451d0484d0761e82f60e",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/FlowHub.sol": "project/contracts/FlowHub.sol",
    "contracts/SpokeOApp.sol": "project/contracts/SpokeOApp.sol",
    "contracts/lz/ILayerZeroEndpointV2.sol": "project/contracts/lz/ILayerZeroEndpointV2.sol",
    "contracts/lz/ILayerZeroReceiverV2.sol": "project/contracts/lz/ILayerZeroReceiverV2.sol",
    "contracts/lz/LZTypes.sol": "project/contracts/lz/LZTypes.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/FlowHub.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"./lz/ILayerZeroEndpointV2.sol\";\r\nimport \"./lz/ILayerZeroReceiverV2.sol\";\r\nimport \"./lz/LZTypes.sol\";\r\n\r\ncontract FlowHub is ILayerZeroReceiverV2 {\r\n    struct Company {\r\n        address owner;\r\n        bool hasOwnChain;\r\n        uint32 dstEid;    // if hasOwnChain\r\n        string metaURI;\r\n        bool exists;\r\n    }\r\n\r\n    address public owner;\r\n    ILayerZeroEndpointV2 public endpoint;\r\n    uint32 public immutable FLOW_EID;\r\n\r\n    mapping(uint256 => Company) public companies;\r\n    mapping(uint32 => bytes32) public peers; // dstEid => bytes32(abi.encodePacked(address SpokeOApp))\r\n\r\n    // replay / idempotency\r\n    mapping(bytes32 => bool) public seenPayload;\r\n\r\n    event CompanyRegistered(uint256 indexed companyId, address indexed owner, bool hasOwnChain, uint32 dstEid, string metaURI);\r\n    event BlockMirrorInitiated(uint256 indexed companyId, bytes32 payloadHash, uint256 userId, uint256 workspaceId, uint32 dstEid, uint64 nonce);\r\n    event MirrorAcked(uint256 indexed companyId, bytes32 payloadHash, uint32 dstEid, bool ok, bytes32 dstTxHash, uint64 nonce);\r\n\r\n    modifier onlyOwner() { require(msg.sender == owner, \"not owner\"); _; }\r\n\r\n    constructor(address _endpoint, uint32 _flowEid) {\r\n        owner = msg.sender;\r\n        endpoint = ILayerZeroEndpointV2(_endpoint);\r\n        FLOW_EID = _flowEid;\r\n    }\r\n\r\n    function setPeer(uint32 eid, bytes32 peer) external onlyOwner {\r\n        peers[eid] = peer;\r\n    }\r\n\r\n    function registerCompany(\r\n        uint256 companyId,\r\n        address companyOwner,\r\n        bool hasOwnChain,\r\n        uint32 dstEid,\r\n        string calldata metaURI\r\n    ) external onlyOwner {\r\n        require(!companies[companyId].exists, \"exists\");\r\n        companies[companyId] = Company({\r\n            owner: companyOwner,\r\n            hasOwnChain: hasOwnChain,\r\n            dstEid: dstEid,\r\n            metaURI: metaURI,\r\n            exists: true\r\n        });\r\n        emit CompanyRegistered(companyId, companyOwner, hasOwnChain, dstEid, metaURI);\r\n    }\r\n\r\n    // If company has own chain, mirror-first (to Spoke), then we ack to reflect on Flow.\r\n    // If not, Flow is primary (just emit an event here).\r\n    function pushBlock(\r\n        uint256 companyId,\r\n        bytes32 payloadHash,\r\n        uint256 userId,\r\n        uint256 workspaceId,\r\n        uint64 nonce,\r\n        bytes calldata lzOptions  // executor options (gas, value caps)\r\n    ) external payable {\r\n        Company memory c = companies[companyId];\r\n        require(c.exists, \"company?\");\r\n        require(msg.sender == c.owner || msg.sender == owner, \"not authorized\");\r\n\r\n        if (!c.hasOwnChain) {\r\n            // Flow primary â€” nothing to send; you can emit an indexable event here too.\r\n            emit MirrorAcked(companyId, payloadHash, FLOW_EID, true, bytes32(0), nonce);\r\n            return;\r\n        }\r\n\r\n        bytes32 peer = peers[c.dstEid];\r\n        require(peer != bytes32(0), \"peer?\");\r\n\r\n        // payload: companyId | payloadHash | userId | workspaceId | nonce\r\n        bytes memory message = abi.encode(companyId, payloadHash, userId, workspaceId, nonce);\r\n\r\n        LZTypes.MessagingParams memory params = LZTypes.MessagingParams({\r\n            dstEid: c.dstEid,\r\n            receiver: peer,\r\n            message: message,\r\n            options: lzOptions,\r\n            payInLzToken: address(0)\r\n        });\r\n\r\n        emit BlockMirrorInitiated(companyId, payloadHash, userId, workspaceId, c.dstEid, nonce);\r\n        endpoint.send{value: msg.value}(params, msg.sender);\r\n    }\r\n\r\n    // Receiver for ACKs coming back from SpokeOApp\r\n    function lzReceive(\r\n        LZTypes.Origin calldata origin,\r\n        bytes32 guid,\r\n        bytes calldata message,\r\n        address /*executor*/,\r\n        bytes calldata /*extraData*/\r\n    ) external override {\r\n        require(msg.sender == address(endpoint), \"not endpoint\");\r\n        require(peers[origin.srcEid] != bytes32(0), \"unknown src\");\r\n        // decode ack: companyId, payloadHash, ok, dstTxHash, nonce\r\n        (uint256 companyId, bytes32 payloadHash, bool ok, bytes32 dstTxHash, uint64 nonce) =\r\n            abi.decode(message, (uint256, bytes32, bool, bytes32, uint64));\r\n\r\n        // idempotency\r\n        bytes32 key = keccak256(abi.encode(origin.srcEid, guid, companyId, payloadHash, nonce));\r\n        if (seenPayload[key]) return;\r\n        seenPayload[key] = true;\r\n\r\n        emit MirrorAcked(companyId, payloadHash, origin.srcEid, ok, dstTxHash, nonce);\r\n    }\r\n\r\n    // rescue\r\n    function withdraw(address payable to) external onlyOwner {\r\n        to.transfer(address(this).balance);\r\n    }\r\n}\r\n"
      },
      "project/contracts/lz/ILayerZeroEndpointV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\nimport \"./LZTypes.sol\";\r\n\r\ninterface ILayerZeroEndpointV2 {\r\n    function send(\r\n        LZTypes.MessagingParams calldata params,\r\n        address refundAddress\r\n    ) external payable returns (LZTypes.MessagingReceipt memory);\r\n\r\n    function getSendLibrary(address oapp) external view returns (address);\r\n}\r\n"
      },
      "project/contracts/lz/ILayerZeroReceiverV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\nimport \"./LZTypes.sol\";\r\n\r\ninterface ILayerZeroReceiverV2 {\r\n    function lzReceive(\r\n        LZTypes.Origin calldata origin,\r\n        bytes32 guid,\r\n        bytes calldata message,\r\n        address executor,\r\n        bytes calldata extraData\r\n    ) external;\r\n}\r\n"
      },
      "project/contracts/lz/LZTypes.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nlibrary LZTypes {\r\n    struct Origin {\r\n        uint32 srcEid;\r\n        bytes32 sender; // abi.encodePacked(address) from EVM chains\r\n        uint64 nonce;\r\n    }\r\n\r\n    struct MessagingReceipt {\r\n        bytes32 guid;\r\n        uint64 nonce;\r\n    }\r\n\r\n    struct MessagingParams {\r\n        uint32 dstEid;\r\n        bytes32 receiver;\r\n        bytes message;\r\n        bytes options; // executor options (gas, value, etc.)\r\n        address payInLzToken; // address(0) => native\r\n    }\r\n}\r\n"
      },
      "project/contracts/SpokeOApp.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"./lz/ILayerZeroEndpointV2.sol\";\r\nimport \"./lz/ILayerZeroReceiverV2.sol\";\r\nimport \"./lz/LZTypes.sol\";\r\n\r\ncontract SpokeOApp is ILayerZeroReceiverV2 {\r\n    address public owner;\r\n    ILayerZeroEndpointV2 public endpoint;\r\n    uint32 public immutable LOCAL_EID;\r\n\r\n    // allowlisted hub per srcEid\r\n    mapping(uint32 => bytes32) public hubs; // srcEid => hub (bytes32 packed address)\r\n    mapping(bytes32 => bool) public seenPayload;\r\n\r\n    event BlockMirrored(uint256 indexed companyId, bytes32 payloadHash, uint32 srcEid, bytes32 dstTxHash, uint64 nonce);\r\n\r\n    modifier onlyOwner() { require(msg.sender == owner, \"not owner\"); _; }\r\n\r\n    constructor(address _endpoint, uint32 _eid) {\r\n        owner = msg.sender;\r\n        endpoint = ILayerZeroEndpointV2(_endpoint);\r\n        LOCAL_EID = _eid;\r\n    }\r\n\r\n    function setHub(uint32 srcEid, bytes32 hub) external onlyOwner {\r\n        hubs[srcEid] = hub;\r\n    }\r\n\r\n    // Receive mirror request from FlowHub\r\n    function lzReceive(\r\n        LZTypes.Origin calldata origin,\r\n        bytes32 guid,\r\n        bytes calldata message,\r\n        address /*executor*/,\r\n        bytes calldata /*extraData*/\r\n    ) external override {\r\n        require(msg.sender == address(endpoint), \"not endpoint\");\r\n    uint32 srcEid = origin.srcEid;\r\n    bytes32 hub = hubs[srcEid];\r\n    require(hub != bytes32(0), \"unknown src\");\r\n    // enforce that sender matches allowlisted hub\r\n    require(origin.sender == hub, \"bad sender\");\r\n\r\n        // decode: companyId, payloadHash, userId, workspaceId, nonce\r\n        (uint256 companyId, bytes32 payloadHash, , , uint64 nonce) =\r\n            abi.decode(message, (uint256, bytes32, uint256, uint256, uint64));\r\n\r\n    bytes32 key = keccak256(abi.encode(srcEid, guid, companyId, payloadHash, nonce));\r\n        if (seenPayload[key]) {\r\n            // already processed, just drop (idempotent)\r\n            return;\r\n        }\r\n        seenPayload[key] = true;\r\n\r\n        // Persist minimally (event-first for analytics; storage optional)\r\n        // You could also map (companyId => latest payloadHash) if desired.\r\n        bytes32 dstTxHash = bytes32(uint256(uint160(address(this)))) ^ keccak256(abi.encode(block.number, companyId, payloadHash));\r\n    emit BlockMirrored(companyId, payloadHash, srcEid, dstTxHash, nonce);\r\n\r\n        // ACK back to FlowHub\r\n        bytes memory ack = abi.encode(companyId, payloadHash, true, dstTxHash, nonce);\r\n        LZTypes.MessagingParams memory params = LZTypes.MessagingParams({\r\n            dstEid: srcEid,\r\n            receiver: hub,\r\n            message: ack,\r\n            options: bytes(\"\"), // can set executor gas if needed\r\n            payInLzToken: address(0)\r\n        });\r\n        endpoint.send(params, address(0));\r\n    }\r\n\r\n    function withdraw(address payable to) external onlyOwner {\r\n        to.transfer(address(this).balance);\r\n    }\r\n}\r\n"
      }
    }
  }
}