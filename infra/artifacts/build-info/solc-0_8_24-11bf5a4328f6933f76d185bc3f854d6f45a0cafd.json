{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-11bf5a4328f6933f76d185bc3f854d6f45a0cafd",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/SpokeOApp.sol": "project/contracts/SpokeOApp.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/lz/ILayerZeroEndpointV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\nimport \"./LZTypes.sol\";\r\n\r\ninterface ILayerZeroEndpointV2 {\r\n    function send(\r\n        LZTypes.MessagingParams calldata params,\r\n        address refundAddress\r\n    ) external payable returns (LZTypes.MessagingReceipt memory);\r\n\r\n    function getSendLibrary(address oapp) external view returns (address);\r\n}\r\n"
      },
      "project/contracts/lz/ILayerZeroReceiverV2.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\nimport \"./LZTypes.sol\";\r\n\r\ninterface ILayerZeroReceiverV2 {\r\n    function lzReceive(\r\n        LZTypes.Origin calldata origin,\r\n        bytes32 guid,\r\n        bytes calldata message,\r\n        address executor,\r\n        bytes calldata extraData\r\n    ) external;\r\n}\r\n"
      },
      "project/contracts/lz/LZTypes.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nlibrary LZTypes {\r\n    struct Origin {\r\n        uint32 srcEid;\r\n        bytes32 sender; // abi.encodePacked(address) from EVM chains\r\n        uint64 nonce;\r\n    }\r\n\r\n    struct MessagingReceipt {\r\n        bytes32 guid;\r\n        uint64 nonce;\r\n    }\r\n\r\n    struct MessagingParams {\r\n        uint32 dstEid;\r\n        bytes32 receiver;\r\n        bytes message;\r\n        bytes options; // executor options (gas, value, etc.)\r\n        address payInLzToken; // address(0) => native\r\n    }\r\n}\r\n"
      },
      "project/contracts/SpokeOApp.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"./lz/ILayerZeroEndpointV2.sol\";\r\nimport \"./lz/ILayerZeroReceiverV2.sol\";\r\nimport \"./lz/LZTypes.sol\";\r\n\r\n/**\r\n * @title SpokeOApp\r\n * @notice Receives mirror requests from FlowHub (on Flow EVM), emits an indexable event,\r\n *         and ACKs back to FlowHub via LayerZero v2.\r\n *\r\n * Design notes:\r\n * - We allowlist a single Hub per srcEid (Flow EVM testnet in your setup).\r\n * - We use an idempotency map keyed by (srcEid, guid, companyId, payloadHash, nonce).\r\n * - For the ACK, we send the message's `guid` back in the `dstTxHash` field (on-chain code cannot read its own tx hash).\r\n * - `ackFeeWei` lets you provision native to fund the ACK send; fund the Spoke with native and set this value.\r\n */\r\ncontract SpokeOApp is ILayerZeroReceiverV2 {\r\n    // ---------------------------------------------------------------------\r\n    // Storage\r\n    // ---------------------------------------------------------------------\r\n\r\n    address public owner;\r\n    ILayerZeroEndpointV2 public endpoint;\r\n    uint32 public immutable LOCAL_EID;\r\n\r\n    // Allowlisted hub per srcEid (packed EVM address as bytes32)\r\n    mapping(uint32 => bytes32) public hubs; // srcEid => hub\r\n\r\n    // Idempotency guard for processed payloads\r\n    mapping(bytes32 => bool) public seenPayload;\r\n\r\n    // Native fee to attach when sending the ACK back to the hub\r\n    uint256 public ackFeeWei;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Events\r\n    // ---------------------------------------------------------------------\r\n\r\n    event BlockMirrored(\r\n        uint256 indexed companyId,\r\n        bytes32 payloadHash,\r\n        uint32 srcEid,\r\n        bytes32 dstTxHashLike, // we use LZ guid here\r\n        uint64 nonce\r\n    );\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Modifiers\r\n    // ---------------------------------------------------------------------\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(address _endpoint, uint32 _eid) {\r\n        owner = msg.sender;\r\n        endpoint = ILayerZeroEndpointV2(_endpoint);\r\n        LOCAL_EID = _eid;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Admin\r\n    // ---------------------------------------------------------------------\r\n\r\n    /// @notice Set the allowlisted hub for a given srcEid\r\n    function setHub(uint32 srcEid, bytes32 hub) external onlyOwner {\r\n        hubs[srcEid] = hub;\r\n    }\r\n\r\n    /// @notice Configure the native fee used for ACK sends\r\n    function setAckFeeWei(uint256 v) external onlyOwner {\r\n        ackFeeWei = v;\r\n    }\r\n\r\n    /// @notice Allow funding the contract with native (for ACK fees)\r\n    receive() external payable {}\r\n\r\n    /// @notice Withdraw any native stuck in the contract\r\n    function withdraw(address payable to) external onlyOwner {\r\n        to.transfer(address(this).balance);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // LayerZero receive\r\n    // ---------------------------------------------------------------------\r\n\r\n    /// @dev Receive mirror request from FlowHub\r\n    function lzReceive(\r\n        LZTypes.Origin calldata origin,\r\n        bytes32 guid,\r\n        bytes calldata message,\r\n        address /*executor*/,\r\n        bytes calldata /*extraData*/\r\n    ) external override {\r\n        require(msg.sender == address(endpoint), \"not endpoint\");\r\n\r\n        uint32 srcEid = origin.srcEid;\r\n        bytes32 hub = hubs[srcEid];\r\n        require(hub != bytes32(0), \"unknown src\");\r\n        // enforce that the sender matches the allowlisted hub\r\n        require(origin.sender == hub, \"bad sender\");\r\n\r\n        // decode: companyId, payloadHash, userId, workspaceId, nonce\r\n        (uint256 companyId, bytes32 payloadHash, , , uint64 nonce) =\r\n            abi.decode(message, (uint256, bytes32, uint256, uint256, uint64));\r\n\r\n        // idempotency key across (srcEid, guid, companyId, payloadHash, nonce)\r\n        bytes32 key = keccak256(abi.encode(srcEid, guid, companyId, payloadHash, nonce));\r\n        if (seenPayload[key]) {\r\n            // already processed; drop\r\n            return;\r\n        }\r\n        seenPayload[key] = true;\r\n\r\n        // Emit indexable event on destination chain.\r\n        // We can't read our own tx hash on-chain, so use the LZ `guid` as a stable, unique id.\r\n        emit BlockMirrored(companyId, payloadHash, srcEid, guid, nonce);\r\n\r\n        // Prepare ACK back to the hub on Flow EVM:\r\n        // We return (companyId, payloadHash, ok=true, dstTxHashLike=guid, nonce)\r\n        bytes memory ack = abi.encode(companyId, payloadHash, true, guid, nonce);\r\n\r\n        LZTypes.MessagingParams memory params = LZTypes.MessagingParams({\r\n            dstEid: srcEid,\r\n            receiver: hub,\r\n            message: ack,\r\n            options: bytes(\"\"),          // can add executor gas options later if desired\r\n            payInLzToken: address(0)     // pay in native\r\n        });\r\n\r\n        // Send ACK (attach configured native to cover LZ executor fees)\r\n        endpoint.send{value: ackFeeWei}(params, address(0));\r\n    }\r\n}\r\n"
      }
    }
  }
}